3.66

A. CNT=7
B. struct a_struct { int idx; int x[6]; };

这里要注意的是，生成的汇编代码中使用了一个技巧。这样就不容易看出来地址间的运算关
系了：

    10 add 0x4(%ecx,%ebx,1), %edx ; memory[bp+28i+4] + 7i -> edx
    13 mov %eax, 0x(%ecx,%edx,4) ; eax -> memory[bp+4*edx+8]

我们把 10 行的 edx 的值，带入 13 行中，可以得到：

    bp + 4 + 4 + 4*? + 28i

而在前面的第 10 行，我们其实已经取出了 idx 的值了：

    10 add 0x4(%ecx,%ebx,1), %edx ; memory[bp+4 + 28i]

汇编代码在 bp+4+28i 的地址处取出 4 个字节的值，然后又在 bp+4+28i + 4 + 4*? 的地
址处写入一个值（这个值就是 n）。通过观察，我们就可以知道这个地址寻址的规律了：
a_struct 前面有 4 个字节需要跳过，然后才到数组的寻址，而这个数组的每个元素也是 4
个字节的。
